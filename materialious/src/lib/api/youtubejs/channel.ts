import { YT, YTNodes } from 'youtubei.js';
import { getInnertube } from '.';
import type { ChannelContent, ChannelOptions, ChannelPage, Image, Video } from '../model';
import { invidiousItemSchema } from './schema';

export async function getChannelYTjs(channelId: string): Promise<ChannelPage> {
	const innertube = await getInnertube();

	const innerResults = await innertube.getChannel(channelId);

	const authorId = innerResults.metadata.url?.split('/')[4] ?? '';

	let authorBanners: Image[] = [];
	if (innerResults.header?.is(YTNodes.PageHeaderView)) {
		authorBanners = innerResults.header.banner?.image ?? [];
	}

	return {
		type: 'channel',
		allowedRegions: innerResults.metadata.available_countries ?? [],
		tabs: innerResults.tabs.map((tab) => tab.toLowerCase()),
		latestVideos: [],
		isFamilyFriendly: true,
		author: innerResults.metadata.title ?? '',
		authorThumbnails: innerResults.metadata.avatar ?? [],
		authorId: authorId,
		authorBanners,
		joined: 0,
		authorVerified: true,
		totalViews: 0,
		authorUrl: `/channel/${authorId}`,
		subCount: 0,
		autoGenerated: false,
		description: '',
		descriptionHml: ''
	};
}

export function invidiousChannelContentSchema(
	innerResults: YT.Channel | YT.ChannelListContinuation,
	author: string
) {
	const videos: Video[] = [];

	let contents;
	if (
		innerResults instanceof YT.Channel &&
		innerResults.current_tab?.content?.is(YTNodes.RichGrid)
	) {
		contents = innerResults.current_tab.content.contents;
	} else if (
		innerResults instanceof YT.ChannelListContinuation &&
		innerResults.contents?.is(YTNodes.AppendContinuationItemsAction)
	) {
		contents = innerResults.contents.contents;
	}

	if (!contents) return videos;

	contents.forEach((item) => {
		if (item.is(YTNodes.RichItem)) {
			const invidiousSchema = invidiousItemSchema(item.content);
			if (invidiousSchema?.type === 'video') {
				invidiousSchema.author = author;
				videos.push(invidiousSchema);
			}
		}
	});

	return videos;
}

async function fetchChannelContentWithContinuation(
	channelId: string,
	innerResults: YT.Channel | YT.ChannelListContinuation,
	author: string
): Promise<ChannelContent> {
	const channelContent: ChannelContent = {
		continuation: innerResults.has_continuation ? 'logicalPlaceholder' : undefined,
		videos: invidiousChannelContentSchema(innerResults, author)
	};

	if (channelContent.continuation) {
		channelContent.getContinuation = async () => {
			const continuation = await innerResults.getContinuation();
			return fetchChannelContentWithContinuation(channelId, continuation, author);
		};
	}

	return channelContent;
}

export async function getChannelContentYTjs(
	channelId: string,
	options: ChannelOptions
): Promise<ChannelContent> {
	const innertube = await getInnertube();

	const channel = await innertube.getChannel(channelId);

	const author = channel.metadata.title ?? '';

	let innerResults: YT.Channel | YT.ChannelListContinuation;
	if (options.type === 'videos') {
		innerResults = await channel.getVideos();
	} else if (options.type === 'playlists') {
		innerResults = await channel.getPlaylists();
	} else if (options.type === 'shorts') {
		innerResults = await channel.getShorts();
	} else {
		innerResults = await channel.getLiveStreams();
	}

	return fetchChannelContentWithContinuation(channelId, innerResults, author);
}
